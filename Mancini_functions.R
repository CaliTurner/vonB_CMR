
extract.Nhats <- function(Cm.inputs, real.estimates){
  data.0 <- Cm.inputs$CJS.data$data
  
  phats <- real.estimates[grep("p", real.estimates$parameter),]
  phihats <- real.estimates[grep("Phi", real.estimates$parameter),]
  
  phats[which(phats[,"estimate"] < 0.001), c("estimate", "se", "lcl", "ucl")] <- NA
  if (nrow(phats) == 1){
    phats %>% slice(rep(1, each = (length(colnames(data.0))-1))) -> phats
  }
  phats$season <- colnames(data.0)[1:(ncol(data.0)-1)]
  
  n.caught <- colSums(data.0)
  
  model.averaged.Phi <- model.average(Cm.results, parameter = "Phi")
  
  Nhats.df <- data.frame(season = colnames(data.0)[1:(ncol(data.0)-1)],
                         Nhat = (n.caught[1:(length(n.caught) - 1)]/phats$estimate) ) %>%
    mutate(SE_Nhat = (n.caught[1:(length(n.caught) - 1)]/phats$estimate) * phats$se/phats$estimate,
           #lcl  = (n.caught[2:length(n.caught)]/phats$lcl) * p.residents,
           #ucl = (n.caught[2:length(n.caught)]/phats$ucl) * p.residents,
           lcl = (n.caught[1:(length(n.caught)-1)]/phats$estimate)  - 1.96 * SE_Nhat,
           ucl = (n.caught[1:(length(n.caught)-1)]/phats$estimate)  + 1.96 * SE_Nhat,
           lcl2 = ifelse(lcl < 0, 0, lcl))
  
  out.list <- list(phats = phats,
                   Nhats = Nhats.df,
                   Phihats = phihats,
                   Phihat_avg = model.averaged.Phi)
  return(out.list)
}

extract.Nhats.jags <- function(Cm.inputs, real.estimates){
  data.0 <- Cm.inputs$CJS.data$data

  Nhats <- real.estimates[grep("N[", real.estimates$parameter, fixed = T),] %>%
    transmute(parameter = parameter,
              mean = mean,
              sd = sd,
              lcl = `2.5%`,
              median = `50%`,
              ucl = `97.5%`,
              Rhat = Rhat,
              season = colnames(data.0))
  
  Phihats <- real.estimates[grep("phi", real.estimates$parameter, fixed = T),] %>%
    transmute(parameter = parameter,
              mean = mean,
              sd = sd,
              lcl = `2.5%`,
              median = `50%`,
              ucl = `97.5%`,
              Rhat = Rhat)
  
  Gammahats <- real.estimates[grep("gamma", real.estimates$parameter, fixed = T),] %>%
    transmute(parameter = parameter,
              mean = mean,
              sd = sd,
              lcl = `2.5%`,
              median = `50%`,
              ucl = `97.5%`,
              Rhat = Rhat)
  
  out.list <- list(Nhats = Nhats,
                   Phihats = Phihats,
                   Gammahats = Gammahats)
  return(out.list)
}

do_analysis <- function(dp, ddl)
{
  # create formulas for Phi
  # tsm is time-since-marking; check for transient effects
  Phi.dot <-  list(formula = ~ 1)  
  #Phi.weight <- list(formula= ~ min_weight)   # many missing data 
  #Phi.t <- list(formula = ~ time)             # we never have this model worked for turtles... 
  #Phi.season <- list(formula = ~ sum_win)      # this also is unlikely... 
  #Phi.transience <- list(formula = ~ Transient)
  Phi.tsm <- list(formula = ~ tsm)
  
  #create formulas for p
  p.dot <- list(formula = ~ 1)
  p.t <- list(formula = ~ time)
  p.tsm <- list(formula = ~ tsm)
  #p.transience <- list(formula = ~ Transient)
  #p.tsm.transience <- list(formula = ~ tsm + Transient)
  #p.t.transience <- list(formula = ~ time + Transient)
  p.effort <- list(formula = ~ effort)
  p.season <- list(formula = ~ sum_win)
  p.tsm.season <- list(formula = ~ tsm + sum_win)
  p.tsm.effort <- list(formula = ~ tsm + effort)
  
  # create all combinations 
  cml <- create.model.list("CJS")
  
  # run all all models and return as a list with class marklist
  results <- mark.wrapper(cml,
                          data=dp,
                          ddl=ddl,
                          output=FALSE,
                          silent=TRUE)
  return(results)
}


Cm.vonBert.jags.data <- function(dat.1){
  # remove rows with is.na(CCL) is true:
  dat.1 %>% filter(!is.na(CCL)) -> dat.2
  
  n.cap.ID <- table(dat.2$ID)
  recap.ID <- data.frame(n.cap.ID[n.cap.ID > 2])
  colnames(recap.ID) <- c("ID", "Freq")
  
  recap.ID %>% left_join(dat.2, by = "ID") -> recap.data
  
  # Make length and capture date matrices
  unique.ID <- recap.ID$ID
  size.mat <- date.mat <- matrix(nrow = length(unique.ID),
                                 ncol = max(recap.data$Freq))
  
  date.1 <- structure(numeric(length(unique.ID)), class = "Date")
  n.vec <- vector(mode = "numeric", length = length(unique.ID))
  
  k <- 1
  for (k in 1:length(unique.ID)){
    tmp.ID <- filter(recap.data, ID == as.character(unique.ID[k]))
    size.mat[k, 1:nrow(tmp.ID)] <- tmp.ID$CCL
    date.mat[k, 1:nrow(tmp.ID)] <- tmp.ID$DATE - min(tmp.ID$DATE)
    date.1[k] <- min(tmp.ID$DATE)
    n.vec[k] <- nrow(tmp.ID)
  }
  
  date.mat <- date.mat[, 2:ncol(date.mat)]/365
  
  jags.data <- list(nIndiv = length(unique.ID),
                    n = n.vec,
                    L = size.mat,
                    t = date.mat)
  
  return(list(jags.data = jags.data,
              ID = unique.ID))
}



vonBert.jags.data <- function(dat.1, sp.code){
  # remove rows with is.na(CCL) is true:
  dat.1 %>% filter(species == sp.code) %>%
    filter(!is.na(CCL)) -> dat.2
  
  n.cap.ID <- table(dat.2$ID)
  recap.ID <- data.frame(n.cap.ID[n.cap.ID > 2])
  colnames(recap.ID) <- c("ID", "Freq")
  
  recap.ID %>% left_join(dat.2, by = "ID") -> recap.data
  
  # Make length and capture date matrices
  unique.ID <- recap.ID$ID
  size.mat <- date.mat <- matrix(nrow = length(unique.ID),
                                 ncol = max(recap.data$Freq))
  
  date.1 <- structure(numeric(length(unique.ID)), class = "Date")
  n.vec <- vector(mode = "numeric", length = length(unique.ID))
  
  k <- 1
  for (k in 1:length(unique.ID)){
    tmp.ID <- filter(recap.data, ID == as.character(unique.ID[k]))
    size.mat[k, 1:nrow(tmp.ID)] <- tmp.ID$CCL
    date.mat[k, 1:nrow(tmp.ID)] <- tmp.ID$DATE - min(tmp.ID$DATE)
    date.1[k] <- min(tmp.ID$DATE)
    n.vec[k] <- nrow(tmp.ID)
  }
  
  date.mat <- date.mat[, 2:ncol(date.mat)]/365
  
  jags.data <- list(nIndiv = length(unique.ID),
                    n = n.vec,
                    L = size.mat,
                    t = date.mat)
  
  return(list(jags.data = jags.data,
              ID = unique.ID))
}

get.data.Cm <- function(filename){
  col.def <- cols(Event_ID = col_character(),
                  Turtle_no = col_integer(),
                  Count = col_integer(),
                  Season = col_character(),
                  Year = col_integer(),
                  Month = col_integer(),
                  Day = col_integer(),
                  Sp_code = col_character(),
                  Turtle_ID = col_character(),
                  Recapture = col_character(),
                  Community_code = col_character(),
                  Start_date = col_date(format = "%m/%d/%Y"),
                  Start_time = col_time(format = "%H:%M"),
                  End_time = col_time(format = "%H:%M"),
                  Tot_hours = col_double(),
                  Tot_hours_estimated = col_double(),
                  Monitoring_type = col_character(),
                  Monitoring_technique = col_character(),
                  Region = col_character(),
                  Site_type_general = col_character(),
                  Type_site_specific = col_character(),
                  Lat = col_double(),
                  Long = col_double(),
                  Capture_date = col_date(format = "%m/%d/%Y"),
                  Species = col_character(),
                  SCL = col_double(),
                  SCW = col_double(),
                  CCL = col_double(),
                  CCW = col_double(),
                  BD = col_double(),
                  PL = col_double(),
                  TTL = col_double(),
                  Weight = col_double(),
                  Sex = col_character(),
                  Right_tag_new = col_character(),
                  Left_tag_new = col_character(),
                  Right_tag_old = col_character(),
                  Left_tag_old = col_character())
  
  dat.1 <- read_csv(file = filename, col_types = col.def)
  
  dat.1 %>% mutate(ID = as.factor(Turtle_ID),
                   CDATE = Capture_date) %>% 
    transmute(ID = ID,
              detect = 1,
              DATE = CDATE,
              season = as.factor(Season),
              SCL = SCL,
              CCL = CCL,
              weight_kg = Weight,
              sex = Sex,
              species = as.factor(Sp_code),
              community = Community_code)-> dat.1
  
  return(dat.1)
}

get.data <- function(filename){
  col.def <- cols(monitoring_event = col_character(),
                  value = col_integer(),
                  season = col_character(),
                  year = col_integer(),
                  month = col_integer(),
                  day = col_integer(),
                  species = col_character(),
                  turtle_code = col_character(),
                  recapture = col_character(),
                  community = col_character(),
                  start_date = col_date(format = "%d/%m/%Y"),
                  tot_hours = col_double(),
                  type_monitoring = col_character(),
                  methodology = col_character(),
                  longitude_net = col_number(),
                  type_site_gen = col_character(),
                  type_site_spec = col_character(),
                  site_name = col_character(),
                  latitude = col_double(),
                  longitude = col_double(),
                  SCL_CCL = col_double(),
                  SCL = col_double(),
                  SCW = col_double(),
                  CCL = col_double(),
                  CCW = col_double(),
                  BD = col_double(),
                  PL = col_double(),
                  TTL = col_double(),
                  weight_kg = col_double(),
                  sex = col_character(),
                  tipe_monitoring = col_character(),
                  BCI = col_double(),
                  Condition = col_character(),
                  Recapture_new = col_character())
  
  dat.1 <- read_csv(file = filename, col_types = col.def)
  
  dat.1 %>% mutate(ID = as.factor(turtle_code),
                   CDATE = as.Date(paste0(year, "-", month, "-", day))) %>% 
    transmute(ID = ID,
              detect = 1,
              species = as.factor(species),
              DATE = CDATE,
              season = as.factor(season),
              SCL = SCL,
              CCL = CCL,
              weight_kg = weight_kg,
              sex = sex)-> dat.1
  
  # "indefindio" species are greens per Agnese 
  # email on 2019-09-04
  dat.1[dat.1$species == "In", "species"] <- "Cm"
  
  return(dat.1)
}

get.data.Ei <- function(filename){
  col.def <- cols(Event_ID = col_character(),
                  Season = col_character(),
                  Species = col_character(),
                  Turtle_ID = col_character(),
                  Recapture = col_character(),
                  Location = col_character(),
                  Start_time = col_time(format = "%H:%m"),
                  End_time = col_time(format = "%H:%m"),
                  Total_hrs = col_double(),
                  Type = col_character(),
                  Metodologia = col_character(),
                  Longitud_lanceos = col_character(),
                  Site_type_general = col_character(),
                  Site_type_specific = col_character(),
                  site_name = col_character(),
                  Lat_Corr = col_double(),
                  Long_Corr = col_double(),
                  Capture_date = col_date(format = "%m/%d/%Y"),
                  Capture_time = col_time(format = "%H:%m"),
                  Turlte_name = col_character(),
                  SCL = col_double(),
                  SCW = col_double(),
                  CCL = col_double(),
                  CCW = col_double(),
                  BD = col_double(),
                  PL = col_double(),
                  TTL = col_double(),
                  Weight = col_double(),
                  Sex = col_character(),
                  tag_r_new = col_character(),
                  tag_l_new = col_character(),
                  tag_r_old = col_character(),
                  tag_l_old = col_character(),
                  Pit_tag = col_character(),
                  pit_new = col_character(),
                  Pit_old = col_character())
  
  dat.1 <- read_csv(file = filename, col_types = col.def)
  
  dat.1 %>% mutate(ID = as.factor(Turtle_ID),
                   CDATE = Capture_date) %>% 
    transmute(ID = ID,
              season = Season,
              detect = 1,
              DATE = CDATE,
              SCL = SCL,
              CCL = CCL,
              weight_kg = Weight,
              sex = Sex)-> dat.1
  
  return(dat.1)
}


dat2CJS <- function(dat.1, save.file = FALSE, filename = "not.saved"){
  
  # Create ID by Date and assign 1s
  tmp <-melt(dat.1, 
             id.vars = c("ID", "season"), 
             measure.vars = "detect")
  
  # make a table with ID by season
  dat.01 <- cast(tmp, 
                 formula = ID ~ season,
                 fun.aggregate = length)
  
  # replace > 1 with ones
  dat.01 <- as.data.frame(dat.01) %>%
    remove_rownames() %>%
    column_to_rownames(var = "ID")
  
  dat.01[(dat.01 > 1)] <- 1
  
  # save file for later
  if (save.file){
    out.name <- filename
    write.csv(dat.01, 
              file = out.name, 
              row.names = T,
              quote = F)
    
  } else {
    out.name <- "not.saved"
  }
  
  out <- list(filename = out.name,
              data = dat.01)
  
  return(out)
  
}


known.state.cjs <- function(ch){
  state <- ch
  for (i in 1:dim(ch)[1]){
    n1 <- min(which(ch[i,]==1))
    n2 <- max(which(ch[i,]==1))
    state[i,n1:n2] <- 1
    state[i,n1] <- NA
  }
  state[state==0] <- NA
  return(state)
}

dat2dat01.year <- function(dat.1, year, save.file = FALSE){
  dat.year <- filter(dat.1, YEAR == year)
  
  # Create ID by Date and assign 1s
  tmp <-melt(dat.year, 
             id.var = c("ID", "DATE"), 
             measure.var = "detect")
  
  # make a table with ID by Date
  dat.01.year <- cast(tmp, ID ~ DATE)
  
  # replace NAs with zeros
  dat.01.year[is.na(dat.01.year)] <- 0
  dat.01.year <- as.data.frame(dat.01.year)
  
  # save file for later
  if (save.file){
    out.name = paste0("data/Cm_01_", year, ".csv")
    write.csv(dat.01.year, 
              file = out.name, 
              row.names = F,
              quote = F)
    
  } else {
    out.name <- "not.saved"
  }
  
  out <- list(filename = out.name,
              data = dat.01.year)
  
  return(out)
  
}


dat2dat01 <- function(dat.1, save.file = FALSE){
  
  # Create ID by Date and assign 1s
  tmp <-melt(dat.1, 
             id.var = c("ID", "season"), 
             measure.var = "detect")
  
  # make a table with ID by year
  dat.01 <- cast(tmp, ID ~ season)
  
  # replace > 1 with ones
  dat.01 <- as.data.frame(dat.01) %>%
    remove_rownames() %>%
    column_to_rownames(var = "ID")
  
  dat.01[(dat.01 > 1)] <- 1
  
  # save file for later
  if (save.file){
    out.name <- "data/Cm_01_all.csv"
    write.csv(dat.01, 
              file = out.name, 
              row.names = T,
              quote = F)
    
  } else {
    out.name <- "not.saved"
  }
  
  out <- list(filename = out.name,
              data = dat.01)
  
  return(out)
  
}


dat2CJS_covCCL <- function(dat.1){
  
  # Create ID by Date and assign 1s
  tmp <-melt(dat.1, 
             id.vars = c("ID", "season"), 
             measure.vars = "CCL")
  
  # make a table with ID by season
  dat.CCL <- reshape2::dcast(tmp, 
                             formula = ID ~ season,
                             value.var = "value",
                             fun.aggregate = mean)
  
  out <- dat.CCL
  return(out)
  
}


compute.LOOIC <- function(loglik, data.vector, MCMC.params){
  n.per.chain <- (MCMC.params$n.samples - MCMC.params$n.burnin)/MCMC.params$n.thin
  
  loglik.vec <- as.vector(loglik)
  loglik.mat <- matrix(loglik.vec[!is.na(data.vector)], 
                        nrow = MCMC.params$n.chains * n.per.chain)
  
  Reff <- relative_eff(exp(loglik.mat),
                       chain_id = rep(1:MCMC.params$n.chains,
                                      each = n.per.chain),
                       cores = 4)
  
  loo.out <- rstanarm::loo(loglik.mat, 
                           r_eff = Reff, 
                           cores = 4, k_threshold = 0.7)
  
  out.list <- list(Reff = Reff,
                   loo.out = loo.out)
  
  return(out.list)  
}

# extract looic and pareto k statistics. the first input (loo.out) should come from compute.LOOIC above. 
pareto.looic.fcn <- function(loo.out, models){
  pareto.k <- lapply(loo.out, 
                     FUN = function(x) x$loo.out)
  
  # find maximum pareto k values
  max.pareto.k <- unlist(lapply(pareto.k,
                                FUN = function(x) max(x$diagnostics$pareto_k)))
  
  # find the models that have max(pareto k) < 0.7
  good.models <- models[which(max.pareto.k < 0.7)]
  good.models.pareto.k <- pareto.k[which(max.pareto.k < 0.7)]
  
  looic.esimates <- lapply(lapply(loo.out[which(max.pareto.k < 0.7)], 
                                  FUN = function(x) x$loo.out),
                           FUN = function(x) x$estimates)
  
  looic <- unlist(lapply(looic.esimates, 
                         FUN = function(x) x["looic", "Estimate"]))
  
  loo.out.list <- lapply(loo.out[which(max.pareto.k < 0.7)], 
                         FUN = function(x) x$loo.out)
  
  # calculate model weights
  model.weights <- loo_model_weights(loo.out.list)
  out.list <- list(model.weights = model.weights,
                   looic = looic,
                   good.models = good.models,
                   good.models.pareto.k = good.models.pareto.k)
}



# Extracting posterior samples of deviance or any other variable from jags output:
extract.samples <- function(varname, zm){
  dev <- unlist(lapply(zm, FUN = function(x) x[, varname]))
  return(dev)
}

