---
title: "Capture recapture analyses for Agnese Mancini"
output: html_notebook
---

This document describes data analysis of Agnese Mancini's data of green turtle capture recapture events. 


Initialize the workspace
```{r}
rm(list=ls())
library(jagsUI)
library(tidyverse)
library(lubridate)
library(reshape)
library(bayesplot)
library(ggridges)
library(RMark)
library(R2ucare)

source("Mancini_functions.R")

do_analysis <- function(dp, ddl)
{
  # create formulas for Phi
  # tsm is time-since-marking; check for transient effects
  Phi.dot <-  list(formula = ~ 1)  
  Phi.weight <- list(formula= ~ min_weight)
  Phi.tsm <- list(formula = ~ tsm)
  Phi.t <- list(formula = ~ time)
  Phi.transience <- list(formula = ~ Transient)
  
  #create formulas for p
  p.dot <- list(formula = ~ 1)
  p.t <- list(formula = ~ time)
  p.tsm <- list(formula = ~ tsm)
  p.transience <- list(formula = ~ Transient)
  p.tsm.transience <- list(formula = ~ tsm + Transient)
  p.t.transience <- list(formula = ~ time + Transient)
  
  # create all combinations 
  cml <- create.model.list("CJS")
  
  # run all all models and return as a list with class marklist
  results <- mark.wrapper(cml,
                          data=dp,
                          ddl=ddl,
                          output=FALSE,
                          silent=TRUE)
  return(results)
}

```

Bring in the data file and get ready for CJS

```{r warning=F}
dat.1 <- get.data("data/GTC_20190725_Tomo_v2.csv")

dat.1 %>% filter(species == "Cm") -> dat.1.Cm

CJS.data <- dat2CJS(dat.1.Cm, save.file = FALSE)

CJS.data$data %>% rownames_to_column(var = "ID") -> data.CJS

dat.1.Cm %>% select(ID, weight_kg) %>% group_by(ID) %>%
  summarise(min_weight = min(weight_kg, na.rm = T)) %>%
  filter(!is.infinite(min_weight)) -> data.weight

data.weight  %>% left_join(data.CJS, by = "ID") %>%
  select(-c("ID", "min_weight")) -> CH.1

data.weight  %>% left_join(data.CJS, by = "ID") %>%
  select(min_weight) -> cov.weight

n.cap <- rowSums(CH.1)
transient.vec <- rep(1, times = length(n.cap))
transient.vec[n.cap > 1] <- 2

# capture history
tmp <- apply(as.matrix(CH.1), MARGIN = 2, FUN = paste0)
CH <- unite(data.frame(tmp), col = "ch", sep = "")
CH$min_weight <- cov.weight
CH$Transient <- transient.vec

# capture dates and difference in years
cap.dates <- paste0(colnames(CJS.data$data), "-01")
delta.dates <- signif(as.numeric(as.Date(cap.dates[2:length(cap.dates)]) -
                                   as.Date(cap.dates[1:(length(cap.dates)-1)]))/365, 1)

# I need to define transience somewhere... but can't do that with individual covariate
# unless I define each individual whether or not they are transients... 
dp <- process.data(CH, model = "CJS", 
                   time.intervals = delta.dates,
                   groups = "Transient",
                   begin.time = 2001)

ddl <- make.design.data(dp)

# add time-since-marking (TSM models) - not sure if I'm doing this right... 
ddl$Phi$tsm <- 1
ddl$Phi$tsm[ddl$Phi$age == 0] <- 0
ddl$p$tsm <- 1
ddl$p$tsm[ddl$p$age == 0] <- 0

cm.results <- do_analysis(dp = dp, ddl = ddl)

```

Compare results using AICc:

```{r}
model.table(cm.results)
```

According to AICc, the best one is Phi(tsm)p(time + Transient). But c-hat > 9!!  So, obviously, this isn't a great model... What to do? 

Look at the estimates:
```{r}
cm.results$Phi.tsm.p.t.transience$results$real
```



R2ucare to do GOF.  There is no GOF for individual covariate models so we need to remove them before checking GOF (from user guide for R2ucare).

```{r}

CH.ucare <- select(CH, -c("min_weight", "Transient"))

# test away! 
test3sr_Cm <- test3sr(as.matrix(CH.1), rep(1, nrow(CH.1)))
test3sm_Cm <- test3sm(as.matrix(CH.1), rep(1, nrow(CH.1)))
test2ct_Cm <- test2ct(as.matrix(CH.1), rep(1, nrow(CH.1)))
test2cl_Cm <- test2cl(as.matrix(CH.1), rep(1, nrow(CH.1)))

# look at the overall results
test_all_Cm <- overall_CJS(as.matrix(CH.1), rep(1, nrow(CH.1)))

```

Look at one at a time:
```{r}
test3sr_Cm$test3sr
```

The entire test was rejected because of some occasions with low p values but mostly they seem okay... that means... ?


```{r}
test3sm_Cm$test3sm
```

These results are with all high p values - this is good with respect to... ? 


```{r}
test2ct_Cm$test2ct
```

This didn't pass either because of a few (16: p = 0.001, 22: p = 0.023, 32: p = 0.046). This test is for ...?


```{r}
test2cl_Cm$test2cl
```

This isn't good because of some occasions (8: p = 0.008, 9: p = 0.031, 11: p = 0.006, 13: p = 0.003, 16: p = 0.021, 20: p = 0.029, 22: p = 0.021, 34: p = 0.007). 


```{r}
test_all_Cm
```

I need to figure out what they mean... 


When just looking at the overall GOF test for CJS, the approximate chat is 2 - a bit higher than what we want it to be (~1).  

c-hat in the Mark output is 2.29.  

Maybe... I need to add transients into the model?  How can I do that? 