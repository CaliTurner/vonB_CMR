---
title: "Capture recapture analyses for Agnese Mancini"
output: html_notebook
---

October 2020.

This document describes data analysis of Agnese Mancini's data of green turtle capture recapture events. IN this version, we use community (sampling site) specific data for estimating survival/capture probability, and derived abundance using CJS models. 


Initialize the workspace
```{r}
rm(list=ls())
library(jagsUI)
library(tidyverse)
library(lubridate)
library(reshape)
library(bayesplot)
library(ggridges)
library(RMark)
library(R2ucare)

source("Mancini_functions.R")

```

Bring in the data file and get ready for CJS

```{r warning=F}
#dat.1 <- get.data("data/GTC_20190725_Tomo_v2.csv")

dat.1.Cm <- get.data.Cm("data/GTC_Cm Data_updated_2020-04-28_TE_v2.csv")

# Group by community and create CJS data for each community
community.names <- levels(as.factor(dat.1.Cm$community))

# some communities don't have enough recaptures to do CMR modeling
c <- 0
k <- 18
p.recap <- vector(mode = "numeric", length = length(community.names))
#community.names.used <- vector(mode = "character", length = length(community.names))

for (k in 1:length(community.names)){
  
  if (!file.exists(paste0("RData/CJS_Cm_RMark_", community.names[k], ".rds"))){
    dat.1.Cm.community <- filter(dat.1.Cm, community == community.names[k])
    CJS.data <- dat2CJS(dat.1.Cm.community, save.file = FALSE)
    n.GT2.cap <- length(which(rowSums(CJS.data$data) > 1))
    p.recap[k] <- n.GT2.cap/nrow(CJS.data$data)
    
    if (p.recap[k] > 0.05){
      #community.names.used[c + 1] <- community.names[k]
      CJS.data$data %>% rownames_to_column(var = "ID") -> CH.1 #data.CJS
      
      # using R2ucare::group_data to combine CHs
      CH.2 <- R2ucare::group_data(CJS.data$data, rep(1, nrow(CJS.data$data)))
      
      # need to count how many capture events occurred per season
      dat.1.Cm.community %>% select(season, "DATE") %>% 
        group_by(season) %>% #-> tmp3
        summarise(effort = n_distinct(DATE)) -> effort.season
      
      # capture history
      tmp <- apply(as.matrix(CH.2[, 1:(ncol(CH.2)-1)]), 
                   MARGIN = 2,
                   FUN = paste0)
      
      CH <- unite(data.frame(tmp),
                  col = "ch",
                  sep = "")
      
      CH$freq <- CH.2$effY
      
      # capture dates and difference in years
      cap.dates <- paste0(colnames(CJS.data$data), "-01")
      delta.dates <- signif(as.numeric(as.Date(cap.dates[2:length(cap.dates)]) -
                                       as.Date(cap.dates[1:(length(cap.dates)-1)]))/365, 1)
      
      # a possibility of survival changing between summer/winter?
      tmp <- strsplit(colnames(CJS.data$data), split = "-")
      tmp2 <- lapply(tmp, FUN = function(x) x[2])
      tmp3 <- unlist(tmp2)
      
      begin.year <- year(min(dat.1.Cm.community$DATE, na.rm = T))
      dp <- process.data(CH, 
                         model = "CJS", 
                         time.intervals = delta.dates,
                         begin.time = begin.year)
      
      ddl <- make.design.data(dp)
      
      # effort affects the capture probability (p)
      effort.season <- effort.season[1:length(levels(ddl$p$time)),]
      
      effort.season$time <- as.factor(begin.year + cumsum(delta.dates))
      
      ddl$p <- merge_design.covariates(ddl$p, df = effort.season)
      
      # summer/winter affects capture probability (maybe)
      sum_win <- data.frame(sum_win = unlist(ifelse(tmp3 == "08", "summer", "winter")) [1:length(levels(ddl$p$time))],
                            time = as.factor(begin.year + cumsum(delta.dates)))
      
      ddl$p <- merge_design.covariates(ddl$p, df = sum_win)
      
      # summer/winter affects survival (maybe)
      sum_win <- data.frame(sum_win = unlist(ifelse(tmp3 == "08", "summer", "winter")) [1:length(levels(ddl$p$time))],
                            time = as.factor(begin.year + cumsum(c(0, delta.dates[1:(length(delta.dates)-1)]))))
      
      ddl$Phi <- merge_design.covariates(ddl$Phi, df = sum_win)
      
      # add time-since-marking (TSM models) - not sure if I'm doing this right... 
      # When age = 0, it is the first time turtles were caught group(1)
      # all others are group(2), which are recaptures. 
      ddl$Phi$tsm <- 1
      ddl$Phi$tsm[ddl$Phi$age == 0] <- 2
      
      ddl$p$tsm <- 1
      ddl$p$tsm[ddl$p$age == 0] <- 2
      
      Cm.results <- do_analysis(dp = dp, ddl = ddl)
      
      Cm.CJS.input <- list(raw.data = dat.1.Cm.community,
                           CJS.data = CJS.data,
                           CH.1 = CH.1,
                           CH.R2ucare = CH.2,
                           effort = effort.season,
                           CH = CH,
                           delta.dates = delta.dates,
                           dp = dp,
                           ddl = ddl,
                           run.date = Sys.Date())
      
      saveRDS(Cm.results, 
              file = paste0("RData/CJS_Cm_RMark_", community.names[k], ".rds"))
      saveRDS(Cm.CJS.input, 
              file = paste0("RData/CJS_Cm_RMark_input_", community.names[k], ".rds"))
      
    } else {
      print(paste("Commuinity", community.names[k], 
                  "did not have sufficient recapture probability (p < 0.05)."))
      c <- c + 1
    }
    
  }
  
}


```

#### Goodness-of-fit

Of ```r length(community.names)``` communities, there were ```r length(community.names) - c``` communities for which CJS models could be fit. Others (n = ```r c``` did not have sufficient numbers of recaptures.

```{r GOF_test3sr, echo=FALSE, include=F, cache=T}
#CJS.data$data %>% rownames_to_column(var = "ID") -> CH.1 #data.CJS
library(R2ucare)

# using R2ucare::group_data to combine CHs
# these need to be done for each community
k <-  1
c <- 0
test3sr_Cm <- test3sm_Cm <- test2ct_Cm <- test2cl_Cm <- vector(mode = "list", length = length(community.names))
for (k in 1:length(community.names)){
  output.filename <- paste0("RData/CJS_Cm_RMark_input_", community.names[k], ".rds")
  if (file.exists(output.filename)){
    results.k <- readRDS(file = output.filename)
    #CH.Ucare <-R2ucare::group_data(CJS.data$data, effX = rep(1, nrow(CJS.data$data)))
    CH.Ucare <- results.k$CH.R2ucare
    # TEST3.SR tests the hypothesis that there is no difference among previously and newly marked
    #individuals captured at time (i) in the probability of being recaptured at some later time > i (i.e., that
    #whether or not an animal is ever encountered again is not a function of whether or not it is newly
    #marked).
    test3sr_Cm[[c+1]] <- list(community = community.names[k],
                              test.out = test3sr(as.matrix(CH.Ucare[, 1:(ncol(CH.Ucare)-1)]), 
                                                 freq = CH.Ucare$effY)) 
    
    test3sm_Cm[[c+1]] <- list(community = community.names[k],
                              test.out = test3sm(as.matrix(CH.Ucare[, 1:(ncol(CH.Ucare)-1)]), 
                                 freq = CH.Ucare$effY))

    test2ct_Cm[[c+1]] <- list(community = community.names[k],
                              test.out = test2ct(as.matrix(CH.Ucare[, 1:(ncol(CH.Ucare)-1)]), 
                                                 freq = CH.Ucare$effY))

    test2cl_Cm[[c+1]] <- list(community = community.names[k],
                              test.out = test2cl(as.matrix(CH.Ucare[, 1:(ncol(CH.Ucare)-1)]), 
                                                 freq = CH.Ucare$effY))
    c <- c + 1

  }
}
 
# # Need to do some GOF testing here.
# 
# test3sr.signif <- filter(test3sr.details, p_val < 0.05)
# test3sr.signif.01 <- filter(test3sr.details, p_val < 0.01)
```

##### TEST3.SR
TEST3.SR asks "of those individuals seen either on or before occasion (i), what proportion were ever seen again?" According to the Book (Mark Book), it states that "If TEST3.SR is rejected, then this suggests that there is a difference in 'survival' among individuals, depending on whether or not they were seen for the first time either on or before occasion (i)." 

There were ```r nrow(test3sr.signif)``` occasions that were flagged by this statistic (Table 2). Note that if we decrease the alpha level to 0.01, ```r nrow(test3sr.signif.01)``` occasions would be flagged. (I know this is not the correct way to do a statistical analysis but just pointing out the somewhat arbitrary nature of the significance tests.)

```{r table_test3sr, echo=F, include=T}
knitr::kable(test3sr.signif, 
             digits = 2,
             col.names = c("Occasion", "Stat", "p val", "signed test", "test"),
             caption = "Table 2. Significant results from Test3.sr, which evaluates difference in survival among individuals depending on whether or not they were seen for the first time either on or before the i-th occasion",
             table.attr = "style='width:30%;'")
```

##### TES3.Sm

TEST3.Sm tests the hypothesis that there is no difference in the expected time of first recapture between the ‘new’ and ‘old’ individuals captured at occasion i and seen again at least once. It looks at individuals who were seen again. "Among these individuals seen again, when they were seen again does not depend on whether or not they were seen for the first time at occasion (i)."

```{r test3.sm, echo=F, include=F, cache=T}
# TEST3.Sm tests the hypothesis that there is no difference in the expected
# time of first recapture between the ‘new’ and ‘old’ individuals captured at occasion i and seen again at
# least once

test3sm.details <- test3sm_Cm$details
test3sm.signif <- filter(test3sm.details, p_val < 0.05)
```


```{r table_test3sm, echo=F, include=T}
knitr::kable(test3sm.signif, 
             digits = 2,
             col.names = c("Occasion", "Stat", "p val", "signed test", "test"),
             caption = "Table 3. Significant results from Test3.sm, which evaluates difference in the expected time of first recapture between the ‘new’ and ‘old’ individuals captured at occasion i and seen again at least once",
             table.attr = "style='width:30%;'")
```

##### TEST2.CT

TEST2.CT tests the hypothesis that "there is no difference in the probability of being recaptured at t+1 between those captured and not captured at occasion t, conditional on presence at both occasions.  

```{r test2ct, echo=F, include=F}
# TEST2.CT tests the hypothesis that there is no difference in the probability of being 
# recaptured at i+1 between those captured and not captured at occasion i, conditional 
# on presence at both occasions.

test2ct_Cm.details <- test2ct_Cm$details
test2ct.signif <- filter(test2ct_Cm.details, p_val < 0.05)
```


```{r table_test2ct, echo=F, include=T}
knitr::kable(test2ct.signif, 
             digits = 2,
             col.names = c("Occasion", "DF", "Stat", 
                           "p val", "signed test", "test"),
             caption = "Table 4. Significant results from Test2.ct, which evaluates difference in the probability of being recaptured at t+1 between those captured and not captured at occasion t, conditional on presence at both occasions",
             table.attr = "style='width:30%;'")
```

There were four occasions when the test failed at alpha = 0.05; one (22) was positive and three were negative (4, 16, and 18). With alpha = 0.01, only one (16) was rejected. 

##### TEST2.CL

TEST2.CL tests if there is no difference in the expected time of next capture between the individuals captured and not captured at occasion t conditional on presence at both occasions t and t + 2.  

```{r test2cl, echo=F, include=F, warning=F}
# The null hypothesis being tested in TEST2.CL is that there is no difference in
# the expected time of next recapture between the individuals captured and not captured at occasion i
# conditional on presence at both occasions i and i+2. To date, this test has no ‘simple’ interpretation, but
#it is a component test of the overall TEST2 fit statistic.

test2cl_Cm.details <- test2cl_Cm$details
test2cl.signif <- filter(test2cl_Cm.details, p_val < 0.05)
```


```{r table_test2cl, echo=F, include=T}
knitr::kable(test2cl.signif, 
             digits = 2,
             col.names = c("Occasion", "DF", "Stat", "p val", "test"),
             caption = "Table 5. Significant results from Test2.cl, which evaluates the expected time of next capture between the individuals captured and not captured at occasion t conditional on presence at both occasions t and t + 2",
             table.attr = "style='width:30%;'")
```

```{r}
model.table(Cm.results)
```

According to AICc, the best one is Phi(tsm)p(time). But c-hat > 4 (4.75)!  This is better than before but, obviously, this isn't a great model... What to do? 

Look at the estimates:
```{r}
Cm.results$Phi.tsm.p.t$results$real
```

